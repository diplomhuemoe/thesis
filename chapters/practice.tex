% -*-coding: utf-8-*-
\chapter{Описание практической части}
Данный метод был реализован на языке Scala при помощи фреймворка Apache
Spark, предназначенного для параллельной обработки больших объемов данных,
поскольку для создания словаря требовалась обработка большого текстового
корпуса.

\section{Использованный инструментарий}
В качестве основного языка разработки был выбран Scala. Язык Scala является
современным кроссплатформенным языком, сочетающий возможности функционального и
объектно-ориентированного программирования.

Также широко использовался фреймворк Apache Spark является мощным средством для
реализации параллельных алгоритмов по обработке больших объемов данных на
кластере. Это проект с открытым исходным кодом(open source), предоставляющий
удобный и лаконичный интерфейс для написания программ на языках Scala, Java,
Python и R. Выбор в пользу фреймворка Spark был сделан по нескольким причинам:

\begin{itemize}
  \item В нем есть подсистема для построения графов и работы с ними; 
  \item В нем реализована удобная работа с большими данными посредством реализации собственной структуры данных (RDD);
  \item Один из самых быстрых фреймворков для распределенных вычислений и в связи с этим очень динамично развивающийся.
\end{itemize}

Основная структура данных, используемая в Spark - RDD (Resilient Disturbed
Dataset). Это неизменяемая, устойчивая к сбоям структура данных. То есть по сути
любая операция над RDD порождает новую структуру данных, при этом Spark
хранит всю историю происхождения конкретной RDD, чтобы в случае сбоя можно
было легко восстановить её. Еще одним важным аспектом работы в Spark является
возможность многократного доступа к загруженным в память данным.
Для работы с графами использовался GraphX - один из компонентов Apache
Spark. GraphX основан на концепции bulk-synchronous parallel - модели
параллельных вычислений. Вычисления в этой модели происходят посредством
последовательности супершагов, каждый из них состоит из трех компонент:

\begin{enumerate}
  \item Параллельное вычисление: каждый вычислительный узел выполняет локальные
    вычисления и использует данные находящиеся непосредственно на узле.
    Вычисления протекают асинхронно с остальными узлами, однако они могут
    прерываться сообщениями с других узлов; 
  \item Пересылка сообщений: процесс обмена данными между узлами
  \item Барьерная синхронизация: когда узел достигает барьерной точки (общей для
    всех узлов), он ожидает, пока все остальные узлы не достигнут этого же барьера.
\end{enumerate}

В GraphX эта модель воплощена следующим образом. Выполняется последовательность
супершагов, причем, каждый из них содержит следующие шаги:

\begin{enumerate}
\item Вершины графа получают входящие сообщения от своих соседей, посланные с
  предыдущего супершага; 
\item Основываясь на информации из сообщений, рассчитывается новое значение
  вершины;
\item Отправляются сообщения соседним вершинам.
\end{enumerate}

Эта последовательность супершагов выполняется, пока на каком то шаге не окажется
0 полученных и отправленных сообщений всеми вершинами графа. В соответствии с
описанной концепцией пересылка сообщений возможна только между соседними
вершинами.

Для того чтобы задать граф, необходимо указать RDD вершин графа и RDD
ребер. Причем, кратные ребра и петли в графе допускаются. Еще одной важной
концепцией в GraphX является понятие триплета - обьекта, в котором, помимо
информации о ребре, также хранится информация о вершинах, к нему примыкающих.

\section{Общая схема работы}
Сначала система считывает в RDD набор данных с биграммами и их численными
характеристиками. Он преобразовывается к триплетному виду, то есть это
становится RDD типа ((String, String), Double), так как в наборе данных
содержатся пары слов с поставленными к ним в соответствие числами. Далее из всех
словосочетаний составляется список уникальных слов, который будет использован в
дальнейшем для создания множества вершин.

Дальше начинается работа непосредственно с GraphX. Набор данных теперь
представляет из себя структуру RDD[((String, String), Double)] и при этом каждый
элемент этой структуры представляет из себя ребро. То есть получается, что
множество ребер уже задано. Далее создается RDD вершин на основе списка
уникальных слов: каждое из них становится вершиной и каждой вершине ставится в
соответствие два числа - вероятности внести позитивный и негативный вклады в
текст. По умолчанию эти числа равны 0. Часть вершин из вручную составленного списка
инициализируются посредством замены их вероятностей на 1. 

На сформированном графе запускается алгоритм распространяющейся активации. Его
конкретная реализация основана на следующих супершагах:

\begin{enumerate}
  \item Для каждой вершины с ненулевым значением активации посылаются сообщения
    соседним вершинам с посчитанным значеним активации для них по заданной
    формуле;
  \item Все вершины агрегируют сообщения от своих соседей;
  \item Рассчитывается новое значение активации для каждой вершины на основе
    полученных сообщений. Как правило выбирается наибольшее значение активации,
    среди всех присланных и текущего.
\end{enumerate}

Алгоритм завершает свою работу после того как суммарное значение активации
всего графа перестаёт меняться.

После этого все вершины графа имеют рассчитанные для них значения активации.
Слово и соответствующие ему значения активации записываются в файл,
который и является искомым словарём. 

\section{Архитектура системы}
Архитектура модулей разработанного метода представлена на Рис. 1. Класс
Builder является основным и он возвращает искомый словарь. Первичная обработка
данных происходит в классе Parser. Инициализация графа происходит в классе
Initializer. В классе Converter строятся необходимые структуры данных для графа.
Далее, в классе Activator на инициализированном графе выполняется распространя-
ющаяся активация.

\todo{Диаграмма классов}

\FloatBarrier

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
